begin;

create extension if not exists pgcrypto;

do $$
begin
  begin
    create extension if not exists postgis with schema extensions;
  exception
    when others then
      raise notice 'postgis extension unavailable, skipping geo setup: %', sqlerrm;
  end;
end
$$;

create or replace function public.enforce_single_default_user_address()
returns trigger
language plpgsql
as $$
begin
  if new.is_default then
    update public.user_addresses
    set is_default = false
    where user_id = new.user_id
      and id <> new.id
      and is_default = true;
  end if;

  return new;
end;
$$;

drop trigger if exists trg_user_addresses_single_default on public.user_addresses;
create trigger trg_user_addresses_single_default
before insert or update on public.user_addresses
for each row
execute function public.enforce_single_default_user_address();

create unique index if not exists uq_user_addresses_one_default
on public.user_addresses(user_id)
where is_default = true;

create or replace function public.enforce_single_primary_emergency_contact()
returns trigger
language plpgsql
as $$
begin
  if new.is_primary then
    update public.user_emergency_contacts
    set is_primary = false
    where user_id = new.user_id
      and id <> new.id
      and is_primary = true;
  end if;

  return new;
end;
$$;

drop trigger if exists trg_user_emergency_contacts_single_primary on public.user_emergency_contacts;
create trigger trg_user_emergency_contacts_single_primary
before insert or update on public.user_emergency_contacts
for each row
execute function public.enforce_single_primary_emergency_contact();

create unique index if not exists uq_user_emergency_contacts_one_primary
on public.user_emergency_contacts(user_id)
where is_primary = true;

create table if not exists public.owner_profile_audit_events (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  actor_id uuid references auth.users(id) on delete set null,
  action text not null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index if not exists idx_owner_profile_audit_events_user_created
on public.owner_profile_audit_events(user_id, created_at desc);

create index if not exists idx_owner_profile_audit_events_actor_created
on public.owner_profile_audit_events(actor_id, created_at desc);

alter table public.owner_profile_audit_events enable row level security;

drop policy if exists owner_profile_audit_events_select_owner on public.owner_profile_audit_events;
create policy owner_profile_audit_events_select_owner
on public.owner_profile_audit_events
for select
to authenticated
using (user_id = auth.uid());

drop policy if exists owner_profile_audit_events_select_admin on public.owner_profile_audit_events;
create policy owner_profile_audit_events_select_admin
on public.owner_profile_audit_events
for select
to authenticated
using (public.is_admin());

drop policy if exists owner_profile_audit_events_insert_owner_or_admin on public.owner_profile_audit_events;
create policy owner_profile_audit_events_insert_owner_or_admin
on public.owner_profile_audit_events
for insert
to authenticated
with check (
  (user_id = auth.uid() and actor_id = auth.uid())
  or public.is_admin()
);

create or replace function public.log_owner_profile_audit_event(
  p_user_id uuid,
  p_action text,
  p_metadata jsonb default '{}'::jsonb,
  p_actor_id uuid default auth.uid()
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.owner_profile_audit_events (user_id, actor_id, action, metadata)
  values (p_user_id, p_actor_id, p_action, coalesce(p_metadata, '{}'::jsonb));
end;
$$;

grant execute on function public.log_owner_profile_audit_event(uuid, text, jsonb, uuid)
to authenticated, service_role;

create or replace function public.prevent_sensitive_profile_self_updates()
returns trigger
language plpgsql
as $$
begin
  if auth.role() <> 'service_role' and not public.is_admin() and new.id = auth.uid() then
    if old.cancellation_rate is distinct from new.cancellation_rate
      or old.late_cancellation_count is distinct from new.late_cancellation_count
      or old.no_show_count is distinct from new.no_show_count
      or old.average_rating is distinct from new.average_rating
      or old.total_bookings is distinct from new.total_bookings
      or old.flagged_count is distinct from new.flagged_count
      or old.is_suspended is distinct from new.is_suspended
      or old.is_phone_verified is distinct from new.is_phone_verified
      or old.is_email_verified is distinct from new.is_email_verified
      or old.kyc_status is distinct from new.kyc_status
      or old.government_id_type is distinct from new.government_id_type
      or old.id_document_url is distinct from new.id_document_url
      or old.account_status is distinct from new.account_status
      or old.risk_score is distinct from new.risk_score then
      raise exception 'Sensitive trust fields cannot be modified by profile owner.';
    end if;
  end if;

  return new;
end;
$$;

drop trigger if exists trg_profiles_prevent_sensitive_self_updates on public.profiles;
create trigger trg_profiles_prevent_sensitive_self_updates
before update on public.profiles
for each row
execute function public.prevent_sensitive_profile_self_updates();

do $$
begin
  if exists (
    select 1
    from pg_type t
    join pg_namespace n on n.oid = t.typnamespace
    where t.typname = 'geography'
      and n.nspname = 'extensions'
  ) then
    alter table public.user_addresses
      add column if not exists location extensions.geography(point, 4326);

    create or replace function public.set_user_address_location()
    returns trigger
    language plpgsql
    set search_path = public, extensions
    as $body$
    begin
      if new.latitude is not null and new.longitude is not null then
        new.location = st_setsrid(st_makepoint(new.longitude, new.latitude), 4326)::extensions.geography;
      else
        new.location = null;
      end if;

      return new;
    end;
    $body$;

    drop trigger if exists trg_user_addresses_set_location on public.user_addresses;
    create trigger trg_user_addresses_set_location
    before insert or update of latitude, longitude on public.user_addresses
    for each row
    execute function public.set_user_address_location();

    update public.user_addresses
    set location = case
      when latitude is not null and longitude is not null
        then extensions.st_setsrid(extensions.st_makepoint(longitude, latitude), 4326)::extensions.geography
      else null
    end
    where true;

    create index if not exists idx_user_addresses_location
    on public.user_addresses using gist(location);
  end if;
end
$$;

create index if not exists idx_user_addresses_country_state_city
on public.user_addresses(country, state, city);

create or replace function public.recompute_owner_profile_metrics(p_user_id uuid default null)
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  updated_rows integer;
begin
  with booking_metrics as (
    select
      b.user_id,
      count(*)::integer as total_bookings,
      count(*) filter (where b.status = 'cancelled')::integer as cancelled_count
    from public.bookings b
    where p_user_id is null or b.user_id = p_user_id
    group by b.user_id
  ),
  pet_metrics as (
    select
      p.user_id,
      count(*)::integer as total_pets
    from public.pets p
    where p_user_id is null or p.user_id = p_user_id
    group by p.user_id
  )
  update public.profiles pr
  set
    total_bookings = coalesce(bm.total_bookings, 0),
    late_cancellation_count = coalesce(bm.cancelled_count, 0),
    cancellation_rate = case
      when coalesce(bm.total_bookings, 0) > 0
        then (coalesce(bm.cancelled_count, 0)::numeric / bm.total_bookings::numeric)
      else 0
    end,
    total_pets = coalesce(pm.total_pets, 0),
    updated_at = now()
  from booking_metrics bm
  full outer join pet_metrics pm
    on bm.user_id = pm.user_id
  where pr.id = coalesce(bm.user_id, pm.user_id)
    and (p_user_id is null or pr.id = p_user_id);

  get diagnostics updated_rows = row_count;
  return updated_rows;
end;
$$;

grant execute on function public.recompute_owner_profile_metrics(uuid)
to service_role;

commit;
